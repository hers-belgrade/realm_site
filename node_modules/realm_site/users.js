/**
 * Module dependencies.
 */
var dataMaster = require('./datamaster'),
    hersdata = require('hersdata'),
    UserBase = hersdata.UserBase,
    SessionUser = hersdata.SessionUser,
    Player = require('./Player'),
    _BC_ = new(hersdata.BigCounter)(),
    randomBytes = require('crypto').randomBytes,
    util = require('util'),
    Timeout = require('herstimeout');

dataMaster.commit('users_starting',[
  ['set',['local','users']]
]);
/*
dataMaster.newUser.attach(function(user){
  dataMaster.commit('new_user',[
    ['set',['local','users',user.username]]
  ]);
});
dataMaster.userOut.attach(function(user){
  dataMaster.commit('user_out',[
    ['remove',['local','users',user.username]]
  ]);
});
*/

function Admin(data,username,realmname,roles){
  SessionUser.call(this,data,username,realmname,roles);
}
Admin.prototype = new SessionUser();
Admin.prototype.constructor = Admin;
Admin.prototype.commitTransaction = function(params,statuscb){
  if(!this.data){statuscb('NO_DATA',[]);return;}
  this.data.commit(params.txnalias,params.txns);
  statuscb('OK',[]);
};

var _DBItf;

function userFactory(data,username,realmname,roles,cb){
  if(!_DBItf){
    cb(new Player(data,user,realmname));
    return;
  }
  _DBItf({username: username},function(err, user) {
    if (err) return cb();
    if (!user) return cb();

    console.log('user found in db',user);
    var ra = user.roles.split(',');
    if (ra.indexOf('admin') >= 0){
      cb(new Admin(data,username,realmname,roles));
      return;
    }
    if (ra.indexOf('player') >= 0){
      console.log('it is a player');
      cb(new Player(data,user,realmname));
      //dataMaster.storeUser(u, {balance: user.balance, avatar: user.avatar});
      return;
    }
    cb ();
  });
};

dataMaster.setSessionUserFunctionality({realmName:realmName,userFactory:userFactory});

exports.signout = function(req, res) {
    if (req.user && req.user.username){
      UserBase.removeUser(req.user.username,dataMaster.realmName);
      dataMaster.removeUser(req.user.username);
    }
};

/**
 * Find user by id
 */
exports.user = function(req, res, next, id) {
  User.findOne({ _id: id })
  .exec(function(err, user) {
    if (err) return next(err);
    if (!user) return next(new Error('Failed to load User ' + id));
    req.profile = user;
    next();
  });
};

function now(){
  return (new Date()).getTime();
}
var _now;

exports.dumpData = function(req, res, next) {
  if(!req.user){
    Timeout.set(function(res){res.jsonp({});},10000,res);
    return;
  }
  req.query.name = req.user.username;
  req.query.roles = req.user.roles;
  dataMaster.functionalities.sessionuserfunctionality.f.dumpData(req.query,function(errc,errp,errm){
    if(errc==='OK'){
      res.jsonp(errp[0]);
    }else{
      res.jsonp({errorcode:errc,errorparams:errp,errormessage:errm});
    }
  });
};

exports.execute = function(req, res, next) {
  if(!req.user){
    Timeout.set(function(res){res.jsonp({});},10000,res);
    return;
  }
  req.query.name = req.user.username;
  req.query.roles = req.user.roles;
  dataMaster.functionalities.sessionuserfunctionality.f.produceAndExecute(req.query,function(errc,errp,errm){
    if(errc==='OK'){
      res.jsonp(errp[0]);
    }else{
      res.jsonp({errorcode:errc,errorparams:errp,errormessage:errm});
    }
  });
};


function storeUserToTree (u, cb) {
  if (dataMaster.userExists(u.username)) {
    return cb ();
  }else{
    User.findOne({username: u.username}).exec (function(err, user) {
      if (err) return cb(err);
      if (!user) return cb (new Error('Failed to load User '+username));

      var roles = user.roles.split(',');
      if (roles.indexOf('player') >= 0){
        console.log('will put player into data tree:', u.username);
        if (typeof(user.balance) === 'undefined') {
          user.balance = 2000;
          user.save();
        }
        dataMaster.storeUser(u, {balance: user.balance, avatar: user.avatar});
      }
      cb ();
    });
  }
}

exports.setup = function(app){
  var io = require('socket.io').listen(app, { log: false });
  console.log('socket.io listening');
  io.set('authorization', function(handshakeData, callback){
    var username = handshakeData.query.username;
    var sess = handshakeData.query[dataMaster.functionalities.sessionuserfunctionality.f.fingerprint];
    console.log('sock.io incoming',username,sess);
    if(username && sess){
      var u = dataMaster.functionalities.sessionuserfunctionality.f._findUser(username);
      if(!u){
        callback(null,false);
      }else{
        handshakeData.username = username;
        handshakeData.session = sess;
        callback(null,true);
      }
    }else{
      callback(null,false);
    }
  });
  io.sockets.on('connection',function(sock){
    var username = sock.handshake.username,
      session = sock.handshake.session,
      u = dataMaster.functionalities.sessionuserfunctionality.f._findUser(username);
    //console.log(username,'sockio connected',session,'session',u.sessions);
    u.makeSession(session);
    u.sessions[session].setSocketIO(sock);
    sock.on('!',function(data){
      dataMaster.functionalities.sessionuserfunctionality.f.executeOnUser({user:u,session:session,commands:data},function(errc,errp,errm){
        sock.emit('=',errc==='OK' ? errp[0] : {errorcode:errc,errorparams:errp,errormessage:errm});
      });
    });
  });
};

exports.setDBInterface = function(dbitf){
  _DBItf = dbitf;
};
